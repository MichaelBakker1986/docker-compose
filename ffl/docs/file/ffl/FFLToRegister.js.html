<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">ffl/FFLToRegister.js | ffl-pack</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="core package converting ffl"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ffl-pack"><meta property="twitter:description" content="core package converting ffl"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ffl/DeltaCompareRegister.js~DeltaCompareRegister.html">DeltaCompareRegister</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ffl/Register.js~Register.html">Register</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ffl/RegisterToJSON.js~RegisterToJSON.html">RegisterToJSON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-FinFormula">FinFormula</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-RegisterToFFL">RegisterToFFL</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">ffl/FFLToRegister.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Is a FFL quick-formatter (V05 &apos;3.1m chars&apos; 90ms) and is FFL to indexed formatter
 */
function FFLToRegister(register, data, resolve_parent_name = false) {
	this.resolve_parent_name = resolve_parent_name
	this.register = register
	register.addColumns([&apos;desc&apos;, &apos;parent_name&apos;])
	this.vars = register.getIndex(&apos;i&apos;)
	this.original = data
	this.data = data
	this.reassembled = &apos;&apos;
	this.constants = []
	register.constants = this.constants
	this.comments = []
	this.header = &apos;&apos;
	this.indents = []
	for (let i = 0; i &lt; 30; i++) this.indents[i] = new Array(i).join(&apos; &apos;)
}

/**
 * Extract imports, model name,comments in header
 */
FFLToRegister.prototype.extractHeader = function() {
	this.header = this.original.substring(0, this.original.indexOf(&apos;{&apos;))
	//INFO: the header is not indexed.
	this.register.header = this.header
	const headerLines = this.header.split(&apos;\n&apos;)
	for (let i = 0; i &lt; headerLines.length; i++) {
		const headerLine = headerLines[i].trim()
		let modelName
		if (modelName = headerLine.match(/^\s*model (\w+)/i)) {
			this.name = modelName[1]
			break
		}
	}
}
FFLToRegister.prototype.extractConstants = function() {
	var index = 0
	const constants = this.constants
	this.data = this.data.replace(/&quot;(.*?)&quot;/gm, function($0) {
		constants[++index] = $0
		return &apos;__&apos; + index
	})
}
FFLToRegister.prototype.insertConstants = function() {
	var constants = this.constants
	this.reassembled = this.reassembled.replace(/__(\d+)/gm, function($1, $2) {
		return constants[parseInt($2)]
	})
}
FFLToRegister.prototype.extractComments = function() {
	var comments = {}
	var index = 0
	this.data = this.data.replace(/\/\/.*/gm, function($0) {
		comments[++index] = $0
		return &apos;____&apos; + index
	})
	this.comments = comments
}

FFLToRegister.prototype.removeWhite = function() {
	this.data = this.data.replace(/\s\s+/g, &apos; &apos;)
	//TODO: parse by properties, not by semicolons
	.replace(/;\s+/g, &apos;;&apos;)//7ms of 100ms..(V05) (expensive, but it is removing trailing whitespaces of properties)
}
FFLToRegister.prototype.extractVars = function() {
	var noneexit = true
	var data = this.data
	var index = 0
	const register = this.register
	while (noneexit) {
		noneexit = false
		data = data.replace(/{([^}{]*?)}/gm, function($0, $1, $2) {
			//this happens to many times...
			noneexit = true
			const index = register.addRow([$1, $2, $0.length + $2])
			return &apos;___&apos; + index
		})
	}
}
FFLToRegister.prototype.findRootVariable = function() {
	return this.register.lastRowIndex()

}
FFLToRegister.prototype.buildTree = function() {
	this.extractHeader()
	this.extractConstants()
	this.extractComments()
	this.removeWhite()
	this.extractVars()
	var firstVar = this.findRootVariable()
	this.reassembled = this.prettyFormatFFL(2, firstVar)
	this.insertConstants()
}
FFLToRegister.prototype.walk = function(visit) {
	this.extractHeader()
	this.extractConstants()
	this.extractComments()
	this.removeWhite()
	this.extractVars()
	const firstVar = this.register.lastRowIndex()
	const firstRow = this.vars[firstVar]
	firstRow[0] = firstRow[0].replace(/^\s*root\s*/gi, &apos;variable root &apos;).trim()

	//this is a trick, not wrong!. parent and child index are the same to start with root.
	firstRow.push(&apos;root&apos;, firstVar, null, null, null, null, 0, [], null, this.name, &apos;m&apos;)
	this.walkTree(visit, firstVar, 1)
}
FFLToRegister.prototype.walkTree = function(visit, parentId, depth) {
	const self = this
	const parts = this.vars[parentId][0].trim().split(&apos;;&apos;)
	const child_index = this.register.schemaIndexes.children
	let children = 0
	if (parts[parts.length - 1] === &apos;&apos;) {
		parts.length--
	} else {
		let temp = parts[parts.length - 1]
		parts.length--
		temp.replace(/((?!( variable | tuple )).)+/gm, function($1) {
			//here should go tuple/modifier/refer-to extraction.
			const refIdStartIndex = $1.indexOf(&apos;___&apos;)
			const varDesc = $1.substring(0, refIdStartIndex - 1)
			const tuple = varDesc.startsWith(&apos;tuple&apos;)
			const referIdx = varDesc.toLowerCase().indexOf(&apos;refers to&apos;)
			const referstoVariableName = referIdx !== -1 ? varDesc.substring(referIdx + 10) : null
			const varname = tuple ? referIdx === -1 ? varDesc.substring(6) : varDesc.substring(6, referIdx) : referIdx === -1 ? varDesc.substring(9) : varDesc.substring(9, referIdx)
			const modifier = varname.startsWith(&apos;+=&apos;) ? &apos;+=&apos; : varname.startsWith(&apos;+&apos;) ? &apos;+&apos; : varname.startsWith(&apos;=&apos;) ? &apos;=&apos; : varname.startsWith(&apos;-&apos;) ? &apos;-&apos; : null
			const name = varname.substring(modifier ? modifier.length : 0).trim()//it might be a double space in the end. its too easy to trim.
			const varRefIndex = parseInt($1.substring(refIdStartIndex + 3))

			const variable = self.vars[varRefIndex]
			variable.push(name, varRefIndex, modifier, parentId, tuple, referstoVariableName, children++, [], null, null, tuple ? &apos;t&apos; : &apos;v&apos;)

			self.vars[parentId][child_index].push(variable)
			self.walkTree(visit, varRefIndex, depth + 1)
			return &apos;&apos;
		})
	}
	visit(parentId, parts)
}
//test if this is quicker than indexing, and recreate FFL
//scorecardTool is using this, internally
FFLToRegister.prototype.prettyFormatFFL = function(depth, index) {
	const self = this
	const indent = this.indents[depth]
	const variable = this.vars[index][0].trim()
	const parts = variable.split(&apos;;&apos;)
	const varparts = []
	if (parts[parts.length - 1] === &apos;&apos;) {
		parts.length--
	} else {
		var temp = parts[parts.length - 1]
		parts.length--
		temp.replace(/((?!( variable | tuple )).)+/gm, function($1) {
			const refId = $1.indexOf(&apos;___&apos;)
			varparts.push(indent + $1.substring(0, refId - 1) + &apos;\n&apos; + indent + &apos;{\n&apos; + self.prettyFormatFFL(depth + 1, parseInt($1.substring(refId + 3))) + &apos;\n&apos; + indent + &apos;}&apos;)
			return &apos;&apos;
		})
	}
	var lb = &apos;;\n&apos;
	var r
	if (parts.length === 0) {
		if (varparts.length === 0) {
			r = &apos;&apos;
		} else {
			r = varparts.join(&apos;\n&apos;)
		}
	} else {
		if (varparts.length === 0) {
			r = indent + parts.join(lb + indent) + &apos;;&apos;
		} else {
			r = indent + parts.join(lb + indent) + &apos;;\n&apos; + (varparts.length &gt; 0 ? varparts.join(&apos;\n&apos;) : &apos;;&apos;)
		}
	}
	return r
}
FFLToRegister.prototype.lookupConstant = (index, constants) =&gt; {
	return constants[parseInt(index.substring(2))].replace(/&apos;/g, &apos;\\\&apos;&apos;).replace(/(?:\\r\\n|\\r|\\n)/g, &apos;[br]&apos;)
}
FFLToRegister.prototype.parseProperties = function(resolve_parent_name = this.resolve_parent_name) {
	const { lookupConstant, constants, register } = this
	const formulaMapping = { inputRequired: &apos;required&apos; }
	this.walk((v, raw_properties) =&gt; {
			for (let i = 0; i &lt; raw_properties.length; i++) {
				const p = raw_properties[i]
				const p_seperator_index = p.indexOf(&apos;:&apos;)//can&apos;t use split. some properties use multiple :
				let key = p.substring(0, p_seperator_index).trim()
				key = formulaMapping[key] || key
				register.addColumn(key)
				let value = p.substring(p_seperator_index + 1).trim()
				/**
				 *  (!! doesn&apos;t work with multiple translations in a value) e.g. entirely string
				 * ffl.replace(/__(\d+)/gm, ($1) =&gt; constants[parseInt($1.substring(2))])
				 * ... this does cover too little... title=&quot;Hoi&quot; + VAR01 + &quot;Bye&quot; is nog covered.
				 */
				if (value.startsWith(&apos;__&apos;)) value = lookupConstant(value, constants)
				register.value(v, key, value)
			}
			if (resolve_parent_name) {
				const parent = register.i[v][register.schemaIndexes.parentId]
				if (parent != null) register.value(v, &apos;parent_name&apos;, register.i[parent][register.schemaIndexes.name])
			}
		}
	)
	return register
}
FFLToRegister.prototype.toString = function() {
	this.buildTree()
	return `${this.header}{\n${this.reassembled}\n}`
}
exports.FFLToRegister = FFLToRegister</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
