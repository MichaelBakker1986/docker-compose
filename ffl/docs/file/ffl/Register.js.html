<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">ffl/Register.js | ffl-pack</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="core package converting ffl"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ffl-pack"><meta property="twitter:description" content="core package converting ffl"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ffl/DeltaCompareRegister.js~DeltaCompareRegister.html">DeltaCompareRegister</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ffl/Register.js~Register.html">Register</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ffl/RegisterToJSON.js~RegisterToJSON.html">RegisterToJSON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-FinFormula">FinFormula</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-RegisterToFFL">RegisterToFFL</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">ffl/Register.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * All indexed will be linked to a array of values, like a DB structure
 * Creating a simple-typed DB is easy. When this functionality in growing exponentially introduce in memory-db..
 * For now this is a easy data-structure for many problems. very close to JS/NodeJS
 * @constructor
 */
export class Register {

	header = &apos;&apos;
	schema = []
	createdIndexes = []
	schema_defaults = []
	changes = []

	constructor(schema_defaults = [&apos;desc&apos;, &apos;start&apos;, &apos;end&apos;, &apos;name&apos;, &apos;index&apos;, &apos;modifier&apos;, &apos;parentId&apos;, &apos;tuple&apos;, &apos;refersto&apos;, &apos;tree_index&apos;, &apos;children&apos;, &apos;valid&apos;, &apos;title&apos;, &apos;type&apos;, &apos;parent_name&apos;]) {//expect &apos;valid&apos; to exist) {
		this.schema_defaults = schema_defaults
		this.clean()
	}

	clean() {
		this.header = null
		this.constants = []
		this.formatters = []
		for (let j = 0; j &lt; this.createdIndexes.length; j++) delete this[this.createdIndexes[j]]
		this.createdIndexes = []
		this.schema.length = 0
		this.i = []
		this.schemaIndexes = {}
		//somehow &apos;valid&apos; is a real important property
		//{{MODEL_VARIABLENAME_undefined}} will exist when &apos;valid&apos; is not added to the list here. (since valid is created on demand in RegisterToLMEParser
		//Something alike if (VARIABLENAME.pattern) VARIABLENAME.valid = if(VARIABLENAME.test(VARIABLENAME),&apos;&apos;,&apos;Invalid Input&apos;)
		//therefore adding the property &apos;valid &apos;too late while parsing.
		for (let j = 0; j &lt; this.schema_defaults.length; j++) this.addColumn(this.schema_defaults[j])
	}

	setFormatters(formatters) {
		for (let i = 0; i &lt; formatters.length; i++) this.formatters[i] = formatters[i]
	}

	findByName(n) {
		return this.getNames()[n]
	}

	getNames() {
		return this.getIndex(&apos;name&apos;)
	}

	getIndex(name) {
		if (!this[name]) this.createIndex(name)
		return this[name]
	}

	lastRowIndex() {
		return this.i.length - 1
	}

	addColumns(names) {
		names.forEach(name =&gt; this.addColumn(name))
	}

	addColumn(name) {
		if (this.schemaIndexes[name] == null) {
			this.schemaIndexes[name] = this.schema.length
			this.schema.push(name)
		}
	}

	removeColumn(name) {
		const schemaIds = this.schemaIndexes
		if (schemaIds[name] != null) {
			const index = schemaIds[name]
			for (let i = 0; i &lt; this.i.length; i++) {
				this.i[i].splice(index, 1)
			}
			delete schemaIds[name]
			this.schema.splice(index, 1)
			this.schema.forEach((el, i) =&gt; schemaIds[el] = i)
		}
	}

	flush() {
		for (let i = 0; i &lt; this.i.length; i++) this.i[i].length = this.schema.length
	}

	value(idx, key, value) {
		this.i[idx][this.schemaIndexes[key]] = value
	}

	findStream(key, value, start) {
		return this.find(key, value, this.mark)
	}

	find(key, value, start) {
		const result = []
		for (let i = (start || 0); i &lt; this.i.length; i++) if (this.i[i][this.schemaIndexes[key]] === value) result.push(this.i[i])
		return result
	}

	distinct(schema, start) {
		return this.distinctArr(this.i, schema, start || this.mark)
	}

	distinctArr(arr, schema, start) {
		const result = []
		const combi = {}
		const schemaIndexes = this.schemaIndexes
		const distinctIndex = schema.map((el) =&gt; schemaIndexes[el])
		for (let i = (start || 0); i &lt; arr.length; i++) {
			const row = arr[i]
			let key = &apos;&apos;
			for (let j = 0; j &lt; distinctIndex.length; j++) key += &apos;_&apos; + row[distinctIndex[j]]
			if (!combi[key]) {
				result.push(row)
				combi[key] = true
			}
		}
		return result
	}

//can only be unique indexes, string based.
	addIndex(name) {
		this.createIndex(name)
		return this[name]
	}

//can only be unique indexes, string based.
	createIndex(name) {
		if (!this[name]) {
			this.createdIndexes.push(name)
			const index = {}, i = this.i, ni = this.schemaIndexes[name]
			for (let c = 0; c &lt; i.length; c++) index[i[c][ni]] = i[c]
			this[name] = index
		}
	}

//this will also update indexes...
	addRowSave(row) {
		this.i.push(row)
		for (let i = 0; i &lt; this.createdIndexes.length; i++) {
			const index = this.createdIndexes[i]
			this[index][row[this.schemaIndexes[index]]] = row
		}
		return this.i.length - 1
	}

//insert (quick)
	addRows(rows) {
		return rows.map(row =&gt; this.addRow(row))
	}

	initRows(rows) {
		return rows.map(([row, extra]) =&gt; this.initRow(row, extra))
	}

	initRow(row, extra) {
		const indexes = this.schemaIndexes
		return this.addRow(extra.reduce((init, { col, val }) =&gt; {
			init[indexes[col]] = val
			return init
		}, row))
	}

	addRow(row) {
		this.i.push(row)
		return this.i.length - 1
	}

	/*Inheritance belongs to the Register! this data-structure supports it. DB+Inheritance data-model */
	inheritProperty(name, paramIndex) {
		const variable = this.getIndex(&apos;name&apos;)[name]
		if (variable[paramIndex]) return variable[paramIndex]
		if (variable[this.schemaIndexes.refersto]) return this.inheritProperty(variable[this.schemaIndexes.refersto], paramIndex)
		return &apos;&apos;
	}

	doProx(name, metaData, param) {
		const register = this
		const variable = this.getIndex(&apos;name&apos;)[name]
		Object.defineProperty(metaData, &apos;value&apos;, {
			set: (value) =&gt; {
				variable[param] = value
				register.changes.push({ name, param })
			},
			get: () =&gt; register.inheritProperty(name, param)
		})
	}

	createInformationObject(name, hidden) {
		const variable = []
		for (let paramIndex = 0; paramIndex &lt; this.schema.length; paramIndex++) {
			let propertyName = this.schema[paramIndex]

			if (hidden.indexOf(paramIndex) !== -1) continue
			const metaData = { name: propertyName }
			this.doProx(name, metaData, paramIndex)
			variable.push(metaData)
		}
		return variable
	}

	getAll(name) {
		const r = [], index = this.i, indexpos = this.schemaIndexes[name]
		for (let i = 0; i &lt; index.length; i++) r[i] = index[i][indexpos]
		return r
	}

	walk(node, depth, visitor) {
		visitor(node, depth)
		const children = node[this.schemaIndexes.children]
		for (let i = 0; i &lt; children.length; i++) this.walk(children[i], depth + 1, visitor)
	}

	print = (idxMap, start, filter) =&gt; this.printArr(this.i, idxMap, this.mark || start, filter)

	printArr(arr, idxMap, start, filter) {
		filter = filter || []
		const tout = []
		const self = this
		const filtermap = []
		for (let i = 0; i &lt; filter.length; i++) filtermap[this.schemaIndexes[filter[i]]] = true
		const f = function(el, idx) {
			return filtermap[idx]
		}
		for (let i = (start || 0); i &lt; arr.length; i++) {
			const el = arr[i]
			tout.push((filter.length &gt; 0 ? el.filter(f) : el).map(function(innerEl, idx) {
				const v = self.formatters[idx] ? self.formatters[idx](innerEl) : innerEl
				const prefix = []
				prefix.length = Math.max(idxMap[idx] - String(v).length, 0)
				return String(v).slice(0, idxMap[idx] - 1) + prefix.join(&apos; &apos;)
			}).join(&apos;|&apos;))
		}
		return tout
	}

	translateKeys(formula) {
		const constants = this.constants
		return formula.replace(/__(\d+)/gm, ($1, $2) =&gt; constants[parseInt($2)]) || &apos;&apos;
	}

	iterateRows(addition_property, stream) {
		const names = this.getNames(), parent_name_index = this.schemaIndexes.parent_name,
		      extra                                      = this.schemaIndexes[addition_property],
		      root                                       = names.root
		this.i.filter(row =&gt; row[this.schemaIndexes.name] !== &apos;root&apos;).forEach((row, index) =&gt; stream(index, row, names[row[parent_name_index]] || root, row[extra]))
	}

	/** * mark current moment as last checkpoint */
	markNow() {
		this.mark = this.i.length
	}

	toString() {
		return `variables:[${this.i.length}]\nSchema:[${this.schema.map((el, i) =&gt; el + &apos;:&apos; + i).join(&apos;,&apos;)}]\n${this.i.join(&apos;\n&apos;)}`
	}
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
