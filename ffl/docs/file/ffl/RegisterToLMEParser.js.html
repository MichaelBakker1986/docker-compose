<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">ffl/RegisterToLMEParser.js | ffl-pack</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="core package converting ffl"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ffl-pack"><meta property="twitter:description" content="core package converting ffl"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ffl/DeltaCompareRegister.js~DeltaCompareRegister.html">DeltaCompareRegister</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ffl/Register.js~Register.html">Register</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ffl/RegisterToJSON.js~RegisterToJSON.html">RegisterToJSON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-FinFormula">FinFormula</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-RegisterToFFL">RegisterToFFL</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">ffl/RegisterToLMEParser.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const SolutionFacade = require(&apos;../../src/SolutionFacade&apos;)
const RegisterToFFL = require(&apos;./RegisterToFFL&apos;).RegisterToFFL
const RegisterFormulaBuilder = require(&apos;./RegisterFormulaBuilder&apos;)
const FinFormula = require(&apos;./FinFormula&apos;)
const AST = require(&apos;../../../ast-node-utils/index&apos;).ast
const log = require(&apos;log6&apos;)
const esprima = require(&apos;esprima&apos;)

/**
 * ffl parsing, supports refers-to, modifiers. internationalization. v1:{@fflparser.js} field-validations
 * V2
 *  Quicker, cleaner, flexible, less data-loss                w
 *   1) Indexing makes lookups while processing data more efficient and use less code.
 *   2) Prefer [&quot;a&quot;,&quot;b&quot;].join(&apos;&apos;) above &quot;a&quot; + &quot;b&quot; its way quicker.
 *   3) The indexer has removed parsing abnormals with propername &quot; visible&quot; etc.. Makes the code more clean
 *   4) Own char-interpreter was more complex than recursive regex-replace.
 *
 * TODO: load property names in DB which directly correspond, fix defaults while saving.
 * TODO: some exotic choices not work correctly
 */
function RegisterToLMEParser() {
}

RegisterToLMEParser.prototype.name = &apos;ffl2&apos;
RegisterToLMEParser.prototype.headername = &apos;.finance ffl&apos;
RegisterToLMEParser.prototype.walk = function(node, depth, visitor) {
	visitor(node, depth)
	const childs = node[this.childIndex]
	for (var i = 0; i &lt; childs.length; i++) {
		this.walk(childs[i], depth + 1, visitor)
	}
}
RegisterToLMEParser.prototype.deParse = function(data, workbook) {
	if (!workbook.indexer) return null
	return new RegisterToFFL(workbook.indexer).toGeneratedFFL(undefined, workbook.modelName)
}
RegisterToLMEParser.prototype.parseData = function(data, workbook) {
	const indexer = data
	workbook.indexer = indexer

	const self = this
	const fflRegister = new RegisterToFFL(indexer)
	const register = data.getIndex(&apos;name&apos;)
	const rfb = new RegisterFormulaBuilder(indexer)
	const modelName = workbook.modelName || indexer.name
	const solution = SolutionFacade.createSolution(modelName || &apos;NEW&apos;)
	const nameIndex = indexer.schemaIndexes.name
	const tupleIndex = indexer.schemaIndexes.tuple
	const validIndex = indexer.schemaIndexes.valid
	const displayOptionsIndex = indexer.schemaIndexes.display_options
	const dataOptionsIndex = indexer.schemaIndexes.data_options
	const lengthIndex = indexer.schemaIndexes.length
	const patternIndex = indexer.schemaIndexes.pattern
	const titleIndex = indexer.schemaIndexes.title
	const referstoIndex = indexer.schemaIndexes.refersto
	const displayTypeIndex = indexer.schemaIndexes.displaytype
	const frequencyIndex = indexer.schemaIndexes.frequency
	const versionIndex = indexer.schemaIndexes.version
	const dataTypeIndex = indexer.schemaIndexes.datatype
	const rangeIndex = indexer.schemaIndexes.range
	const ipprotectedIndex = indexer.schemaIndexes.ipprotected
	const modifierIndex = indexer.schemaIndexes.modifier
	const decimalsIndex = indexer.schemaIndexes.fixed_decimals
	const parentNameIndex = indexer.schemaIndexes.parentId
	const visibleIndex = indexer.schemaIndexes.visible

	this.childIndex = indexer.schemaIndexes.children
	const choiceIndex = indexer.schemaIndexes.choices

	this.formulaIndexes = []
	const formulaIndexes = this.formulaIndexes
	var formulas = [&apos;valid&apos;, &apos;hint&apos;, &apos;locked&apos;, &apos;visible&apos;, &apos;required&apos;, &apos;choices&apos;]
	for (var i = 0; i &lt; formulas.length; i++) {
		//test if the formula is in the model at all
		if (data.schemaIndexes[formulas[i]] != null) this.formulaIndexes.push(data.schemaIndexes[formulas[i]])
	}

	const tuples = []
	/*  var default_frequency = &apos;column&apos;
	 if (register.root) {
	 default_frequency = register.root[frequencyIndex] || &apos;column&apos;
	 }*/
	const rootNode = register.root || indexer.i[0]
	workbook.model_version = rootNode ? rootNode[versionIndex] : &apos;&apos;
	this.walk(rootNode, 3, function(node, depth) {
		if (depth &lt; tuples.length) {
			tuples.length = depth
			while (tuples.length &gt; 0 &amp;&amp; !tuples[depth - 1]) tuples.length--
		}
		const nodeName = node[nameIndex]
		rfb.inherit(node)
		var displaytype = node[displayTypeIndex] || &apos;number&apos;

		var datatype = node[dataTypeIndex] || &apos;number&apos;
		var frequency = node[frequencyIndex] || &apos;column&apos;
		var display_options = node[displayOptionsIndex]
		const title = node[titleIndex] || &apos;&quot;&apos; + nodeName + &apos;&quot;&apos;
		const data_options = node[dataOptionsIndex]
		const ipprotected = node[ipprotectedIndex] || false
		//TODO: paragraph when no children.
		//TODO: else column frequency..
		/*
		 * Don&apos;t forget reference variables
		 * Don&apos;t forget num(1,2) datatype parsing. (fixed_decimals)
		 * Don&apos;t forget unscalable number
		 * Choice -&gt; &quot; and &quot; &lt;- fix
		 * merge display options and displaytype.
		 */
		if (node[tupleIndex]) {
			displaytype = &apos;paragraph&apos;
		}
		if (displaytype == &apos;paragraph&apos;) {
			datatype = &apos;string&apos;
			frequency = &apos;none&apos;
		}
		// expecting an parentName..
		var parentId = node[parentNameIndex] ? indexer.i[node[parentNameIndex]][nameIndex] : null
		//if (parentId == &apos;root&apos;) parentId = undefined;

		/**
		 * number:2 means: number with 2 fixed decimals
		 */
		var fixed_decimals = node[decimalsIndex]
		var startdecimalsIndex
		if ((fixed_decimals == null) &amp;&amp; (startdecimalsIndex = displaytype.indexOf(&apos;(&apos;)) &gt; -1) {
			fixed_decimals = displaytype.substr(startdecimalsIndex).slice(1, -1)
			displaytype = displaytype.substr(0, startdecimalsIndex)
		}
		/**
		 * This is where formula-sets are combined.
		 * if the node has and trend and notrend formula, the target formula will be x.trend ? node.formula_trend : valueFormula
		 * Ofcourse this will be for every formulaset that exists in the node
		 * Document formulaset is notrend, formula = notrend
		 * This way it would also be possible to have and formulaset &apos;orange&apos;, &apos;document&apos; and trend formulasets
		 */
		const valueFormula = rfb.buildFFLFormula(node, frequency == &apos;column&apos; &amp;&amp; datatype == &apos;number&apos;)

		if (node[modifierIndex] &amp;&amp; node[modifierIndex].indexOf(&apos;=&apos;) &gt; -1) display_options = &apos;displayAsSummation&apos;

		//if column &amp;&amp; number.. (aggregate)
		/**
		 * optional displaytype =select.
		 * Having the choice member is enough
		 */
		if (node[choiceIndex] || displaytype == &apos;select&apos;) {
			if (displaytype == &apos;date&apos;) {
				//NO-OP (for now..., the choices are used to format the date-picker.
			}
			else if (!node[choiceIndex]) {
				if (log.debug) log.debug(&apos;Row [&apos; + nodeName + &apos;] is displaytype [select], but does not have choices&apos;)
			} else if (node[choiceIndex].split(&apos;|&apos;).length == 2) {
				displaytype = &apos;radio&apos;
			} else {
				displaytype = &apos;select&apos;
				if (log.TRACE) log.trace(&apos;[&apos; + nodeName + &apos;] &apos; + node.choices)
			}
		}

		//TODO: quick-fix move into IDE ScorecardTool-addon
		if (nodeName.match(/MAP[0-9,A-z]+_(VALIDATION|INFO|HINT|WARNING)$/i)) {
			if (fflRegister.defaultValues[fflRegister.visibleIndex][node[fflRegister.visibleIndex]]) {
				node[fflRegister.visibleIndex] = &apos;Length(&apos; + nodeName + &apos;)&apos;
				frequency = &apos;none&apos;
				node[frequencyIndex] = &apos;none&apos;
			}
			displaytype = &apos;string&apos;
			node[displayOptionsIndex] = nodeName.split(&apos;_&apos;).pop().toLowerCase()
		} else if (nodeName.match(/MAP[0-9,A-z]+_PARAGRAAF[0-9]+$/i)) {
			node[frequencyIndex] = &apos;none&apos;
			frequency = &apos;none&apos;
			displaytype = &apos;paragraph&apos;
		}

		//we also check nodeName here. With root { .. there are two root nodes, one wihout name.
		if (!node[validIndex] &amp;&amp; nodeName) {
			//valid formula&apos;s (this will become more complex soon valid(list&lt;predicate,message&gt;) now predicate,message
			//info: patternIndex is language-specific (f.e. email- regular expression)
			const validFormulas = []
			//pattern is optional
			if (patternIndex &amp;&amp; node[patternIndex]) validFormulas.push(&apos;REGEXPMATCH(&apos; + node[patternIndex] + &apos;,&apos; + nodeName + &apos;)&apos;)
			//length is optional
			if (lengthIndex &amp;&amp; node[lengthIndex]) validFormulas.push(&apos;Length(&apos; + nodeName + &apos;) &apos; + node[lengthIndex])
			//range is optional
			if (rangeIndex &amp;&amp; node[rangeIndex]) validFormulas.push(&apos;(&apos; + node[rangeIndex].replace(/(&gt;|&gt;=|&lt;|&lt;=)/gi, nodeName + &apos; $1&apos;) + &apos;)&apos;)
			if (datatype == &apos;number&apos;) validFormulas.push(&apos;not isNaN(OnNA(&apos; + nodeName + &apos;,null))&apos;)
			//its also only interesting when its a required field and entered
			// or when its entered and required
			//&apos; + node[nameIndex] + &apos;.required &amp;&amp;
			//valid formulas are only interesting when entered OR required
			if (validFormulas.length &gt; 0) node[validIndex] = &apos;If(&apos; + validFormulas.join(&apos; And &apos;) + &apos;,&quot;&quot;,&quot;Enter valid input.&quot;)&apos;
		}

		const uiNode = SolutionFacade.createUIFormulaLink(solution, nodeName, &apos;value&apos;, self.parseFFLFormula(indexer, valueFormula, nodeName, &apos;value&apos;, datatype, workbook.context), displaytype, frequency, null, parentId, ipprotected)

		//hierarchical visibility
		const visibleFormula = node[fflRegister.visibleIndex]
		if (parentId) {
			node[fflRegister.visibleIndex] = fflRegister.defaultValues[visibleIndex][visibleFormula] ? parentId + &apos;.visible&apos; : parentId + &apos;.visible and &apos; + visibleFormula
		}

		if (fixed_decimals) uiNode.decimals = parseInt(fixed_decimals)
		if (display_options) uiNode.display_options = display_options
		if (data_options) uiNode.data_options = data_options

		//should not be needed...
		uiNode.frequency = frequency

		/**
		 * Tuple properties
		 */
		if (node[tupleIndex] || tuples.length &gt; 0) {
			uiNode.tuple = true
			uiNode.nestedTupleDepth = 0
			for (var i = 0; i &lt; tuples.length; i++)
				if (tuples[i]) uiNode.nestedTupleDepth++
			if (node[tupleIndex]) {
				uiNode.tupleDefinition = true
				uiNode.datatype = &apos;string&apos; //Will story string-based values (Jan,Piet,123Jaar,Etc..)
				if (tuples.length &gt; 0) {
					uiNode.tupleDefinitionName = tuples[tuples.length - 1].rowId
					uiNode.tupleProperty = true
				}
				tuples[depth] = uiNode
			} else {
				uiNode.tupleDefinitionName = tuples[tuples.length - 1].rowId
				uiNode.tupleProperty = true
			}
		}

		if (node[fflRegister.options_titleIndex] == &apos;locked&apos;) uiNode.title_locked = true

		uiNode.datatype = datatype

		SolutionFacade.createUIFormulaLink(solution, nodeName, &apos;title&apos;, self.parseFFLFormula(indexer, title, nodeName, &apos;title&apos;, null, workbook.context), undefined, frequency, null, null)

		for (var i = 0; i &lt; formulaIndexes.length; i++) {
			const index = formulaIndexes[i]
			if (node[index]) {
				if (!fflRegister.defaultValues[index] || !fflRegister.defaultValues[index][node[index]]) {
					SolutionFacade.createUIFormulaLink(solution, nodeName, indexer.schema[index], self.parseFFLFormula(indexer, node[index], nodeName, indexer.schema[index], null, workbook.context), undefined, frequency, null, null)
				}
			}
		}
	})
	//think about formula-sets, same ritual as trend + notrend formulasets
	return solution
}

RegisterToLMEParser.prototype.parseFFLFormula = function(indexer, formula, nodeName, col, type, context) {
	if (!formula) return type == &apos;string&apos; ? AST.STRING(&apos;&apos;) : type == &apos;number&apos; ? {
		&apos;type&apos;: &apos;Identifier&apos;,
		&apos;name&apos;: &apos;NA&apos;
	} : {
		&apos;type&apos;: &apos;Identifier&apos;,
		&apos;name&apos;: &apos;null&apos;
	}
	var finparse = col == &apos;choices&apos; ? FinFormula.finChoice(formula) : FinFormula.parseFormula(formula)
	//allow multi-language here
	finparse = indexer.translateKeys(finparse)
	var formulaReturn = &apos;undefined&apos;
	try {
		formulaReturn = esprima.parse(finparse).body[0].expression
	}
	catch (e) {
		if (log.DEBUG) log.debug(&apos;unable to parse [&apos; + finparse + &apos;] returning it as String value [&apos; + nodeName + &apos;] : &apos; + col, e)
		formulaReturn = AST.STRING(finparse)
		if (global.IDE_DEBUGMODUS) context.audittrail.addRow([&apos;MODEL&apos;, &apos;ERROR&apos;, nodeName, col, &apos;&apos;, &apos;&apos;, &apos;&apos;, e.toString(), formula, null, finparse])
	}
	return formulaReturn
}

exports.RegisterToLMEParser = RegisterToLMEParser
SolutionFacade.addParser(RegisterToLMEParser.prototype)</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
