'use strict';

var cov_1m16qsgt43 = function () {
	var path = 'C:\\Users\\mbakk\\Documents\\fesjs\\lme-core\\src\\YAxis.js',
	    hash = '130c3ff96868f0c763294d69acfc34acffe60da4',
	    Function = function () {}.constructor,
	    global = new Function('return this')(),
	    gcv = '__coverage__',
	    coverageData = {
		path: 'C:\\Users\\mbakk\\Documents\\fesjs\\lme-core\\src\\YAxis.js',
		statementMap: {
			'0': {
				start: {
					line: 55,
					column: 28
				},
				end: {
					line: 55,
					column: 30
				}
			},
			'1': {
				start: {
					line: 56,
					column: 23
				},
				end: {
					line: 56,
					column: 24
				}
			},
			'2': {
				start: {
					line: 57,
					column: 31
				},
				end: {
					line: 57,
					column: 33
				}
			},
			'3': {
				start: {
					line: 58,
					column: 31
				},
				end: {
					line: 58,
					column: 76
				}
			},
			'4': {
				start: {
					line: 59,
					column: 31
				},
				end: {
					line: 59,
					column: 76
				}
			},
			'5': {
				start: {
					line: 61,
					column: 27
				},
				end: {
					line: 61,
					column: 54
				}
			},
			'6': {
				start: {
					line: 62,
					column: 27
				},
				end: {
					line: 62,
					column: 54
				}
			},
			'7': {
				start: {
					line: 63,
					column: 27
				},
				end: {
					line: 63,
					column: 54
				}
			},
			'8': {
				start: {
					line: 72,
					column: 29
				},
				end: {
					line: 72,
					column: 72
				}
			},
			'9': {
				start: {
					line: 73,
					column: 0
				},
				end: {
					line: 73,
					column: 61
				}
			},
			'10': {
				start: {
					line: 74,
					column: 29
				},
				end: {
					line: 74,
					column: 72
				}
			},
			'11': {
				start: {
					line: 75,
					column: 0
				},
				end: {
					line: 75,
					column: 63
				}
			},
			'12': {
				start: {
					line: 76,
					column: 29
				},
				end: {
					line: 76,
					column: 72
				}
			},
			'13': {
				start: {
					line: 77,
					column: 0
				},
				end: {
					line: 77,
					column: 65
				}
			},
			'14': {
				start: {
					line: 78,
					column: 29
				},
				end: {
					line: 78,
					column: 78
				}
			},
			'15': {
				start: {
					line: 81,
					column: 16
				},
				end: {
					line: 81,
					column: 18
				}
			},
			'16': {
				start: {
					line: 82,
					column: 0
				},
				end: {
					line: 90,
					column: 1
				}
			},
			'17': {
				start: {
					line: 83,
					column: 1
				},
				end: {
					line: 83,
					column: 20
				}
			},
			'18': {
				start: {
					line: 84,
					column: 1
				},
				end: {
					line: 89,
					column: 2
				}
			},
			'19': {
				start: {
					line: 85,
					column: 2
				},
				end: {
					line: 85,
					column: 29
				}
			},
			'20': {
				start: {
					line: 86,
					column: 2
				},
				end: {
					line: 88,
					column: 3
				}
			},
			'21': {
				start: {
					line: 87,
					column: 3
				},
				end: {
					line: 87,
					column: 126
				}
			},
			'22': {
				start: {
					line: 94,
					column: 0
				},
				end: {
					line: 103,
					column: 1
				}
			},
			'23': {
				start: {
					line: 95,
					column: 1
				},
				end: {
					line: 102,
					column: 2
				}
			},
			'24': {
				start: {
					line: 96,
					column: 2
				},
				end: {
					line: 101,
					column: 3
				}
			},
			'25': {
				start: {
					line: 97,
					column: 17
				},
				end: {
					line: 97,
					column: 33
				}
			},
			'26': {
				start: {
					line: 99,
					column: 3
				},
				end: {
					line: 99,
					column: 103
				}
			},
			'27': {
				start: {
					line: 100,
					column: 3
				},
				end: {
					line: 100,
					column: 137
				}
			},
			'28': {
				start: {
					line: 120,
					column: 18
				},
				end: {
					line: 120,
					column: 20
				}
			},
			'29': {
				start: {
					line: 121,
					column: 26
				},
				end: {
					line: 121,
					column: 67
				}
			},
			'30': {
				start: {
					line: 122,
					column: 0
				},
				end: {
					line: 122,
					column: 98
				}
			},
			'31': {
				start: {
					line: 124,
					column: 0
				},
				end: {
					line: 132,
					column: 1
				}
			},
			'32': {
				start: {
					line: 125,
					column: 1
				},
				end: {
					line: 125,
					column: 22
				}
			},
			'33': {
				start: {
					line: 126,
					column: 1
				},
				end: {
					line: 131,
					column: 2
				}
			},
			'34': {
				start: {
					line: 127,
					column: 2
				},
				end: {
					line: 127,
					column: 31
				}
			},
			'35': {
				start: {
					line: 128,
					column: 2
				},
				end: {
					line: 130,
					column: 3
				}
			},
			'36': {
				start: {
					line: 129,
					column: 3
				},
				end: {
					line: 129,
					column: 86
				}
			},
			'37': {
				start: {
					line: 139,
					column: 0
				},
				end: {
					line: 147,
					column: 1
				}
			},
			'38': {
				start: {
					line: 140,
					column: 1
				},
				end: {
					line: 146,
					column: 2
				}
			},
			'39': {
				start: {
					line: 141,
					column: 2
				},
				end: {
					line: 145,
					column: 3
				}
			},
			'40': {
				start: {
					line: 142,
					column: 17
				},
				end: {
					line: 142,
					column: 33
				}
			},
			'41': {
				start: {
					line: 143,
					column: 13
				},
				end: {
					line: 143,
					column: 31
				}
			},
			'42': {
				start: {
					line: 144,
					column: 3
				},
				end: {
					line: 144,
					column: 183
				}
			},
			'43': {
				start: {
					line: 150,
					column: 1
				},
				end: {
					line: 150,
					column: 13
				}
			},
			'44': {
				start: {
					line: 151,
					column: 1
				},
				end: {
					line: 151,
					column: 11
				}
			},
			'45': {
				start: {
					line: 152,
					column: 1
				},
				end: {
					line: 152,
					column: 75
				}
			},
			'46': {
				start: {
					line: 155,
					column: 14
				},
				end: {
					line: 169,
					column: 1
				}
			},
			'47': {
				start: {
					line: 170,
					column: 0
				},
				end: {
					line: 170,
					column: 18
				}
			},
			'48': {
				start: {
					line: 172,
					column: 0
				},
				end: {
					line: 172,
					column: 31
				}
			},
			'49': {
				start: {
					line: 174,
					column: 0
				},
				end: {
					line: 240,
					column: 1
				}
			},
			'50': {
				start: {
					line: 175,
					column: 1
				},
				end: {
					line: 189,
					column: 2
				}
			},
			'51': {
				start: {
					line: 191,
					column: 1
				},
				end: {
					line: 191,
					column: 95
				}
			},
			'52': {
				start: {
					line: 192,
					column: 1
				},
				end: {
					line: 192,
					column: 70
				}
			},
			'53': {
				start: {
					line: 192,
					column: 16
				},
				end: {
					line: 192,
					column: 70
				}
			},
			'54': {
				start: {
					line: 193,
					column: 1
				},
				end: {
					line: 193,
					column: 66
				}
			},
			'55': {
				start: {
					line: 193,
					column: 16
				},
				end: {
					line: 193,
					column: 66
				}
			},
			'56': {
				start: {
					line: 195,
					column: 1
				},
				end: {
					line: 239,
					column: 2
				}
			},
			'57': {
				start: {
					line: 196,
					column: 2
				},
				end: {
					line: 210,
					column: 3
				}
			},
			'58': {
				start: {
					line: 212,
					column: 2
				},
				end: {
					line: 212,
					column: 141
				}
			},
			'59': {
				start: {
					line: 213,
					column: 2
				},
				end: {
					line: 213,
					column: 102
				}
			},
			'60': {
				start: {
					line: 213,
					column: 18
				},
				end: {
					line: 213,
					column: 102
				}
			},
			'61': {
				start: {
					line: 214,
					column: 2
				},
				end: {
					line: 214,
					column: 98
				}
			},
			'62': {
				start: {
					line: 214,
					column: 18
				},
				end: {
					line: 214,
					column: 98
				}
			},
			'63': {
				start: {
					line: 217,
					column: 2
				},
				end: {
					line: 238,
					column: 3
				}
			},
			'64': {
				start: {
					line: 218,
					column: 3
				},
				end: {
					line: 232,
					column: 4
				}
			},
			'65': {
				start: {
					line: 234,
					column: 3
				},
				end: {
					line: 234,
					column: 170
				}
			},
			'66': {
				start: {
					line: 236,
					column: 3
				},
				end: {
					line: 236,
					column: 130
				}
			},
			'67': {
				start: {
					line: 236,
					column: 18
				},
				end: {
					line: 236,
					column: 130
				}
			},
			'68': {
				start: {
					line: 237,
					column: 3
				},
				end: {
					line: 237,
					column: 126
				}
			},
			'69': {
				start: {
					line: 237,
					column: 18
				},
				end: {
					line: 237,
					column: 126
				}
			},
			'70': {
				start: {
					line: 248,
					column: 0
				},
				end: {
					line: 260,
					column: 1
				}
			},
			'71': {
				start: {
					line: 249,
					column: 15
				},
				end: {
					line: 249,
					column: 16
				}
			},
			'72': {
				start: {
					line: 249,
					column: 32
				},
				end: {
					line: 249,
					column: 34
				}
			},
			'73': {
				start: {
					line: 250,
					column: 22
				},
				end: {
					line: 250,
					column: 48
				}
			},
			'74': {
				start: {
					line: 251,
					column: 1
				},
				end: {
					line: 253,
					column: 2
				}
			},
			'75': {
				start: {
					line: 252,
					column: 2
				},
				end: {
					line: 252,
					column: 54
				}
			},
			'76': {
				start: {
					line: 259,
					column: 1
				},
				end: {
					line: 259,
					column: 19
				}
			},
			'77': {
				start: {
					line: 264,
					column: 0
				},
				end: {
					line: 266,
					column: 1
				}
			},
			'78': {
				start: {
					line: 265,
					column: 1
				},
				end: {
					line: 265,
					column: 38
				}
			},
			'79': {
				start: {
					line: 267,
					column: 0
				},
				end: {
					line: 269,
					column: 1
				}
			},
			'80': {
				start: {
					line: 268,
					column: 1
				},
				end: {
					line: 268,
					column: 42
				}
			},
			'81': {
				start: {
					line: 272,
					column: 15
				},
				end: {
					line: 272,
					column: 189
				}
			},
			'82': {
				start: {
					line: 273,
					column: 15
				},
				end: {
					line: 273,
					column: 183
				}
			},
			'83': {
				start: {
					line: 274,
					column: 1
				},
				end: {
					line: 274,
					column: 178
				}
			},
			'84': {
				start: {
					line: 280,
					column: 0
				},
				end: {
					line: 341,
					column: 1
				}
			},
			'85': {
				start: {
					line: 281,
					column: 11
				},
				end: {
					line: 281,
					column: 13
				}
			},
			'86': {
				start: {
					line: 284,
					column: 1
				},
				end: {
					line: 339,
					column: 2
				}
			},
			'87': {
				start: {
					line: 285,
					column: 12
				},
				end: {
					line: 285,
					column: 21
				}
			},
			'88': {
				start: {
					line: 286,
					column: 19
				},
				end: {
					line: 286,
					column: 21
				}
			},
			'89': {
				start: {
					line: 287,
					column: 15
				},
				end: {
					line: 287,
					column: 34
				}
			},
			'90': {
				start: {
					line: 301,
					column: 2
				},
				end: {
					line: 324,
					column: 3
				}
			},
			'91': {
				start: {
					line: 302,
					column: 13
				},
				end: {
					line: 302,
					column: 20
				}
			},
			'92': {
				start: {
					line: 303,
					column: 19
				},
				end: {
					line: 303,
					column: 32
				}
			},
			'93': {
				start: {
					line: 320,
					column: 3
				},
				end: {
					line: 323,
					column: 4
				}
			},
			'94': {
				start: {
					line: 321,
					column: 4
				},
				end: {
					line: 321,
					column: 43
				}
			},
			'95': {
				start: {
					line: 321,
					column: 19
				},
				end: {
					line: 321,
					column: 43
				}
			},
			'96': {
				start: {
					line: 322,
					column: 4
				},
				end: {
					line: 322,
					column: 26
				}
			},
			'97': {
				start: {
					line: 326,
					column: 2
				},
				end: {
					line: 338,
					column: 3
				}
			},
			'98': {
				start: {
					line: 327,
					column: 3
				},
				end: {
					line: 327,
					column: 11
				}
			},
			'99': {
				start: {
					line: 329,
					column: 7
				},
				end: {
					line: 338,
					column: 3
				}
			},
			'100': {
				start: {
					line: 330,
					column: 3
				},
				end: {
					line: 330,
					column: 64
				}
			},
			'101': {
				start: {
					line: 332,
					column: 3
				},
				end: {
					line: 337,
					column: 6
				}
			},
			'102': {
				start: {
					line: 336,
					column: 4
				},
				end: {
					line: 336,
					column: 85
				}
			},
			'103': {
				start: {
					line: 340,
					column: 1
				},
				end: {
					line: 340,
					column: 11
				}
			},
			'104': {
				start: {
					line: 356,
					column: 16
				},
				end: {
					line: 385,
					column: 2
				}
			},
			'105': {
				start: {
					line: 386,
					column: 0
				},
				end: {
					line: 390,
					column: 1
				}
			},
			'106': {
				start: {
					line: 387,
					column: 14
				},
				end: {
					line: 387,
					column: 32
				}
			},
			'107': {
				start: {
					line: 388,
					column: 1
				},
				end: {
					line: 388,
					column: 133
				}
			},
			'108': {
				start: {
					line: 388,
					column: 43
				},
				end: {
					line: 388,
					column: 133
				}
			},
			'109': {
				start: {
					line: 389,
					column: 1
				},
				end: {
					line: 389,
					column: 137
				}
			},
			'110': {
				start: {
					line: 389,
					column: 45
				},
				end: {
					line: 389,
					column: 137
				}
			}
		},
		fnMap: {
			'0': {
				name: 'pad',
				decl: {
					start: {
						line: 149,
						column: 9
					},
					end: {
						line: 149,
						column: 12
					}
				},
				loc: {
					start: {
						line: 149,
						column: 26
					},
					end: {
						line: 153,
						column: 1
					}
				},
				line: 149
			},
			'1': {
				name: '(anonymous_1)',
				decl: {
					start: {
						line: 248,
						column: 17
					},
					end: {
						line: 248,
						column: 18
					}
				},
				loc: {
					start: {
						line: 248,
						column: 58
					},
					end: {
						line: 260,
						column: 1
					}
				},
				line: 248
			},
			'2': {
				name: '(anonymous_2)',
				decl: {
					start: {
						line: 264,
						column: 16
					},
					end: {
						line: 264,
						column: 17
					}
				},
				loc: {
					start: {
						line: 264,
						column: 54
					},
					end: {
						line: 266,
						column: 1
					}
				},
				line: 264
			},
			'3': {
				name: '(anonymous_3)',
				decl: {
					start: {
						line: 267,
						column: 22
					},
					end: {
						line: 267,
						column: 23
					}
				},
				loc: {
					start: {
						line: 267,
						column: 41
					},
					end: {
						line: 269,
						column: 1
					}
				},
				line: 267
			},
			'4': {
				name: 'indexToArray',
				decl: {
					start: {
						line: 271,
						column: 9
					},
					end: {
						line: 271,
						column: 21
					}
				},
				loc: {
					start: {
						line: 271,
						column: 32
					},
					end: {
						line: 275,
						column: 1
					}
				},
				line: 271
			},
			'5': {
				name: '(anonymous_5)',
				decl: {
					start: {
						line: 280,
						column: 24
					},
					end: {
						line: 280,
						column: 25
					}
				},
				loc: {
					start: {
						line: 280,
						column: 45
					},
					end: {
						line: 341,
						column: 1
					}
				},
				line: 280
			},
			'6': {
				name: '(anonymous_6)',
				decl: {
					start: {
						line: 332,
						column: 39
					},
					end: {
						line: 332,
						column: 40
					}
				},
				loc: {
					start: {
						line: 332,
						column: 56
					},
					end: {
						line: 337,
						column: 4
					}
				},
				line: 332
			}
		},
		branchMap: {
			'0': {
				loc: {
					start: {
						line: 150,
						column: 5
					},
					end: {
						line: 150,
						column: 13
					}
				},
				type: 'binary-expr',
				locations: [{
					start: {
						line: 150,
						column: 5
					},
					end: {
						line: 150,
						column: 6
					}
				}, {
					start: {
						line: 150,
						column: 10
					},
					end: {
						line: 150,
						column: 13
					}
				}],
				line: 150
			},
			'1': {
				loc: {
					start: {
						line: 152,
						column: 8
					},
					end: {
						line: 152,
						column: 75
					}
				},
				type: 'cond-expr',
				locations: [{
					start: {
						line: 152,
						column: 28
					},
					end: {
						line: 152,
						column: 29
					}
				}, {
					start: {
						line: 152,
						column: 32
					},
					end: {
						line: 152,
						column: 75
					}
				}],
				line: 152
			},
			'2': {
				loc: {
					start: {
						line: 192,
						column: 1
					},
					end: {
						line: 192,
						column: 70
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 192,
						column: 1
					},
					end: {
						line: 192,
						column: 70
					}
				}, {
					start: {
						line: 192,
						column: 1
					},
					end: {
						line: 192,
						column: 70
					}
				}],
				line: 192
			},
			'3': {
				loc: {
					start: {
						line: 193,
						column: 1
					},
					end: {
						line: 193,
						column: 66
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 193,
						column: 1
					},
					end: {
						line: 193,
						column: 66
					}
				}, {
					start: {
						line: 193,
						column: 1
					},
					end: {
						line: 193,
						column: 66
					}
				}],
				line: 193
			},
			'4': {
				loc: {
					start: {
						line: 213,
						column: 2
					},
					end: {
						line: 213,
						column: 102
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 213,
						column: 2
					},
					end: {
						line: 213,
						column: 102
					}
				}, {
					start: {
						line: 213,
						column: 2
					},
					end: {
						line: 213,
						column: 102
					}
				}],
				line: 213
			},
			'5': {
				loc: {
					start: {
						line: 214,
						column: 2
					},
					end: {
						line: 214,
						column: 98
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 214,
						column: 2
					},
					end: {
						line: 214,
						column: 98
					}
				}, {
					start: {
						line: 214,
						column: 2
					},
					end: {
						line: 214,
						column: 98
					}
				}],
				line: 214
			},
			'6': {
				loc: {
					start: {
						line: 236,
						column: 3
					},
					end: {
						line: 236,
						column: 130
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 236,
						column: 3
					},
					end: {
						line: 236,
						column: 130
					}
				}, {
					start: {
						line: 236,
						column: 3
					},
					end: {
						line: 236,
						column: 130
					}
				}],
				line: 236
			},
			'7': {
				loc: {
					start: {
						line: 237,
						column: 3
					},
					end: {
						line: 237,
						column: 126
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 237,
						column: 3
					},
					end: {
						line: 237,
						column: 126
					}
				}, {
					start: {
						line: 237,
						column: 3
					},
					end: {
						line: 237,
						column: 126
					}
				}],
				line: 237
			},
			'8': {
				loc: {
					start: {
						line: 320,
						column: 3
					},
					end: {
						line: 323,
						column: 4
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 320,
						column: 3
					},
					end: {
						line: 323,
						column: 4
					}
				}, {
					start: {
						line: 320,
						column: 3
					},
					end: {
						line: 323,
						column: 4
					}
				}],
				line: 320
			},
			'9': {
				loc: {
					start: {
						line: 320,
						column: 7
					},
					end: {
						line: 320,
						column: 54
					}
				},
				type: 'binary-expr',
				locations: [{
					start: {
						line: 320,
						column: 8
					},
					end: {
						line: 320,
						column: 27
					}
				}, {
					start: {
						line: 320,
						column: 32
					},
					end: {
						line: 320,
						column: 54
					}
				}],
				line: 320
			},
			'10': {
				loc: {
					start: {
						line: 321,
						column: 4
					},
					end: {
						line: 321,
						column: 43
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 321,
						column: 4
					},
					end: {
						line: 321,
						column: 43
					}
				}, {
					start: {
						line: 321,
						column: 4
					},
					end: {
						line: 321,
						column: 43
					}
				}],
				line: 321
			},
			'11': {
				loc: {
					start: {
						line: 326,
						column: 2
					},
					end: {
						line: 338,
						column: 3
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 326,
						column: 2
					},
					end: {
						line: 338,
						column: 3
					}
				}, {
					start: {
						line: 326,
						column: 2
					},
					end: {
						line: 338,
						column: 3
					}
				}],
				line: 326
			},
			'12': {
				loc: {
					start: {
						line: 329,
						column: 7
					},
					end: {
						line: 338,
						column: 3
					}
				},
				type: 'if',
				locations: [{
					start: {
						line: 329,
						column: 7
					},
					end: {
						line: 338,
						column: 3
					}
				}, {
					start: {
						line: 329,
						column: 7
					},
					end: {
						line: 338,
						column: 3
					}
				}],
				line: 329
			}
		},
		s: {
			'0': 0,
			'1': 0,
			'2': 0,
			'3': 0,
			'4': 0,
			'5': 0,
			'6': 0,
			'7': 0,
			'8': 0,
			'9': 0,
			'10': 0,
			'11': 0,
			'12': 0,
			'13': 0,
			'14': 0,
			'15': 0,
			'16': 0,
			'17': 0,
			'18': 0,
			'19': 0,
			'20': 0,
			'21': 0,
			'22': 0,
			'23': 0,
			'24': 0,
			'25': 0,
			'26': 0,
			'27': 0,
			'28': 0,
			'29': 0,
			'30': 0,
			'31': 0,
			'32': 0,
			'33': 0,
			'34': 0,
			'35': 0,
			'36': 0,
			'37': 0,
			'38': 0,
			'39': 0,
			'40': 0,
			'41': 0,
			'42': 0,
			'43': 0,
			'44': 0,
			'45': 0,
			'46': 0,
			'47': 0,
			'48': 0,
			'49': 0,
			'50': 0,
			'51': 0,
			'52': 0,
			'53': 0,
			'54': 0,
			'55': 0,
			'56': 0,
			'57': 0,
			'58': 0,
			'59': 0,
			'60': 0,
			'61': 0,
			'62': 0,
			'63': 0,
			'64': 0,
			'65': 0,
			'66': 0,
			'67': 0,
			'68': 0,
			'69': 0,
			'70': 0,
			'71': 0,
			'72': 0,
			'73': 0,
			'74': 0,
			'75': 0,
			'76': 0,
			'77': 0,
			'78': 0,
			'79': 0,
			'80': 0,
			'81': 0,
			'82': 0,
			'83': 0,
			'84': 0,
			'85': 0,
			'86': 0,
			'87': 0,
			'88': 0,
			'89': 0,
			'90': 0,
			'91': 0,
			'92': 0,
			'93': 0,
			'94': 0,
			'95': 0,
			'96': 0,
			'97': 0,
			'98': 0,
			'99': 0,
			'100': 0,
			'101': 0,
			'102': 0,
			'103': 0,
			'104': 0,
			'105': 0,
			'106': 0,
			'107': 0,
			'108': 0,
			'109': 0,
			'110': 0
		},
		f: {
			'0': 0,
			'1': 0,
			'2': 0,
			'3': 0,
			'4': 0,
			'5': 0,
			'6': 0
		},
		b: {
			'0': [0, 0],
			'1': [0, 0],
			'2': [0, 0],
			'3': [0, 0],
			'4': [0, 0],
			'5': [0, 0],
			'6': [0, 0],
			'7': [0, 0],
			'8': [0, 0],
			'9': [0, 0],
			'10': [0, 0],
			'11': [0, 0],
			'12': [0, 0]
		},
		_coverageSchema: 'd34fc3e6b8297bcde183f5492bcb8fcb36775295'
	},
	    coverage = global[gcv] || (global[gcv] = {});

	if (coverage[path] && coverage[path].hash === hash) {
		return coverage[path];
	}

	coverageData.hash = hash;
	return coverage[path] = coverageData;
}(); /**
      * TUPLES
      *
      * In mathematics a tuple is a finite ordered list (sequence) of elements.
      * An n-tuple is a sequence (or ordered list) of n elements, where n is a non-negative integer.
      * There is only one 0-tuple, an empty sequence.
      * An n-tuple is defined inductively using the construction of an ordered pair.
      * Mathematicians usually write tuples by listing the elements within parentheses and separated by commas; for example,(2, 7, 4, 1, 7) denotes a 5-tuple.
      * Sometimes other symbols are used to surround the elements, such as square brackets "[ ]" or angle brackets "< >". Braces "{ }" are only used in defining arrays in some programming languages such as Java and Visual Basic,
      * but not in mathematical expressions, as they are the standard notation for sets. The term tuplecan often occur when discussing other mathematical objects, such as vectors.
      * In computer science, tuples come in many forms. In dynamically typed languages, such as Lisp,
      * lists are commonly used as tuples.[citation needed] Most typed functional programming languages implement tuples directly as product types, tightly associated with algebraic data types,
      * pattern matching, and destructuring assignment.[2] Many programming languages offer an alternative to tuples, known as record types, featuring unordered elements accessed by label.
      * A few programming languages combine ordered tuple product types and unordered record types into a single construct, as in C structs and Haskell records.
      * Relational databases may formally identify their rows (records) as tuples.
      * Tuples also occur in relational algebra; when programming the semantic web with the Resource Description Framework (RDF); in linguistics; and in philosophy.
      *
      * Bit shifting is only possible for 32bit 2complement int in JavaScript
      * Other trailing indexes are used for Time dimension.
      *   10bit 512cols /20 = aprox 25bookyear
      *
      * We always start on level 0.0.0.0.* meaning we are always living in a TupleContext. The first TupleInstance of the First Tuple Definition node
      *  Tuple instances and Definitions have ONLY! td/tp relations towards the existing Tree-structure based FFL, not regular tree-nodes
      *  In abstract creating a TupleInstance of the First Tuple Definition within the model uses the same stateless object yet another TupleDefinition should use.
      *  So don't confuse these concepts with existing parent-child relations in FFL nodes.
      */

/**
 * Gedachten bij het implementeren van tuples:
 * Van tuple naar tuple *binnen eigen tupleDefinition* word de TupleLocatie gebruikt om berekeningen te doen
 * Van Niet tuple naar tuple worden alle values van alle tupleinstanties terug gegeven
 * van tuple naar niet tuple word de tuple naar 0 gezet (mits anders aangeven) (FirstTuple,LastTuple,MaxTuple,FirstTupleIn....)
 * Formules worden geparsed, daarin is de target(referenceFormula) een propertyReferentie.
 * Dit betekend dat er vantui deze manier gedacht moet worden met het parsen
 * De TargetProperty kan een tuple/niet tuple zijn, en daar moet rekening mee gehouden worden.
 * De YAxis word meegeven van de formule, als er naar een tuple variable referenced word, kan de geparsde formula vanuit een tuple
 * een andere uitwerking hebben dan vanuit een niet-tuple
 *
 * tuple    A: 1
 * tuple    X: A+1 -> a(x,y,z) + 1 = 2
 * variable L: A+1 -> a(x,y,z) + 1 = [1] + 1
 *
 * Een wrapper om de uitvragende Property?
 * TSUM herstellen en de logica verplaatsen naar de uitvragende formule
 * TSUM(tupleNaam) => TSUM(tupleDefinitionCount,propertyNaam,x,y,z)
 *
 * Bij het inlezen van een FFL model, tuple markeren als TupleDefinition
 * Alle kinderen daaronder totaan nieuwe tuple markeren als TupleProperty
 *
 * Bij het uitvragen van een TupleDefinition itereren over alle instanties
 */


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _log = require('log6');

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INSTANCES_PER_TUPLE = (cov_1m16qsgt43.s[0]++, 32);
var BITS_PER_TUPLE = (cov_1m16qsgt43.s[1]++, 6);
var FIRST__TUPLE_START_BIT = (cov_1m16qsgt43.s[2]++, 10);
var SECOND_TUPLE_START_BIT = (cov_1m16qsgt43.s[3]++, FIRST__TUPLE_START_BIT + 1 * BITS_PER_TUPLE);
var THIRD__TUPLE_START_BIT = (cov_1m16qsgt43.s[4]++, FIRST__TUPLE_START_BIT + 2 * BITS_PER_TUPLE);

var FIRST__LEVEL_TUPLE = (cov_1m16qsgt43.s[5]++, 1 << FIRST__TUPLE_START_BIT);
var SECOND_LEVEL_TUPLE = (cov_1m16qsgt43.s[6]++, 1 << SECOND_TUPLE_START_BIT);
var THIRD__LEVEL_TUPLE = (cov_1m16qsgt43.s[7]++, 1 << THIRD__TUPLE_START_BIT);
/*
 * These bitmasks are used to extract the bits for a given n-Tuple (0011***)
 * e.g.
 *  0011000 & 001001 = 001000
 * after extracted 001000 bitshift result with corresponding tuple bit offset 001000 >> 3 = (BIN)001 = (HEX) 1
 *
 * so: (0011000 & 011001) >> 3 = (HEX)3
 */
var FIRST__LEVEL_BITMASK = (cov_1m16qsgt43.s[8]++, parseInt('0000000000001111110000000000', 2)); //000129024
cov_1m16qsgt43.s[9]++;
(0, _assert2.default)(parseInt('0000000000001111110000000000', 2) === 64512);
var SECOND_LEVEL_BITMASK = (cov_1m16qsgt43.s[10]++, parseInt('0000001111110000000000000000', 2)); //008257536
cov_1m16qsgt43.s[11]++;
(0, _assert2.default)(parseInt('0000001111110000000000000000', 2) === 4128768);
var THIRD__LEVEL_BITMASK = (cov_1m16qsgt43.s[12]++, parseInt('1111110000000000000000000000', 2)); //528482304
cov_1m16qsgt43.s[13]++;
(0, _assert2.default)(parseInt('1111110000000000000000000000', 2) === 264241152);
var FOURTH_LEVEL_BITMASK = (cov_1m16qsgt43.s[14]++, parseInt('1111110000000000000000000000000000', 2)); //528482304
//assert(parseInt("1111110000000000000000000000000000", 2) == 264241152)

var indexes = (cov_1m16qsgt43.s[15]++, []);
cov_1m16qsgt43.s[16]++;
for (var first = 0; first < INSTANCES_PER_TUPLE; first++) {
	cov_1m16qsgt43.s[17]++;

	indexes[first] = [];
	cov_1m16qsgt43.s[18]++;
	for (var second = 0; second < INSTANCES_PER_TUPLE; second++) {
		cov_1m16qsgt43.s[19]++;

		indexes[first][second] = [];
		cov_1m16qsgt43.s[20]++;
		for (var third = 0; third < INSTANCES_PER_TUPLE; third++) {
			cov_1m16qsgt43.s[21]++;

			indexes[first][second][third] = FIRST__LEVEL_TUPLE * first + SECOND_LEVEL_TUPLE * second + THIRD__LEVEL_TUPLE * third;
		}
	}
}
/*
 * Check if values are valid
 */
cov_1m16qsgt43.s[22]++;
for (var i = 0; i < INSTANCES_PER_TUPLE; i++) {
	cov_1m16qsgt43.s[23]++;

	for (var j = 0; j < INSTANCES_PER_TUPLE; j++) {
		cov_1m16qsgt43.s[24]++;

		for (var k = 0; k < INSTANCES_PER_TUPLE; k++) {
			var index = (cov_1m16qsgt43.s[25]++, indexes[i][j][k]);
			// log.info(((index & FIRST__LEVEL_BITMASK) >> FIRST__TUPLE_START_BIT) + ',' + ((index & SECOND_LEVEL_BITMASK) >> SECOND_TUPLE_START_BIT) + ',' + (index >> THIRD__TUPLE_START_BIT))
			cov_1m16qsgt43.s[26]++;
			_assert2.default.equal(index >> SECOND_TUPLE_START_BIT >> BITS_PER_TUPLE, index >> THIRD__TUPLE_START_BIT);
			cov_1m16qsgt43.s[27]++;
			_assert2.default.equal(index >> SECOND_TUPLE_START_BIT >> BITS_PER_TUPLE, index >> FIRST__TUPLE_START_BIT >> BITS_PER_TUPLE >> BITS_PER_TUPLE);
		}
	}
}
//Nu de check voor corresponderende context. (matching bits.)
/*
 * bits that are used to check if a value is in there.
 * These are the bit masks used by the tuples 11-17,17-23,23-29 bits from the number
 *
 * So:(index)   00001000001101 belongs to
 *               0  1    *****
 *   (bitmask)  00001000000000
 *
 * So:(index)   01001000032321 does not belong to
 *               1  1    *****
 *   (bitmask)  00001000000000
 *
 * om te achterhalen of een index op interessant is voor een bepaalde tuple
 * voor 0,0,1 is matching 1,1,0 nodig. omdat  0,0,0 niet werkt met de & operator, dus inverse van zichzelf
 */
var matchings = (cov_1m16qsgt43.s[28]++, []);
var MAX_INVERSE_INT32 = (cov_1m16qsgt43.s[29]++, (1 << 20) - 1 << FIRST__TUPLE_START_BIT); //2147481600 , 111111111111111111100000000000
cov_1m16qsgt43.s[30]++;
(0, _assert2.default)(parseInt('111111111111111111110000000000', 2) == (1 << 20) - 1 << FIRST__TUPLE_START_BIT);

cov_1m16qsgt43.s[31]++;
for (var first = 0; first < INSTANCES_PER_TUPLE; first++) {
	cov_1m16qsgt43.s[32]++;

	matchings[first] = [];
	cov_1m16qsgt43.s[33]++;
	for (var second = 0; second < INSTANCES_PER_TUPLE; second++) {
		cov_1m16qsgt43.s[34]++;

		matchings[first][second] = [];
		cov_1m16qsgt43.s[35]++;
		for (var third = 0; third < INSTANCES_PER_TUPLE; third++) {
			cov_1m16qsgt43.s[36]++;

			matchings[first][second][third] = MAX_INVERSE_INT32 - indexes[first][second][third];
		}
	}
}
/*
 * Test if the inverse masks result in 0.
 *0010 : 2
 *1101 :13
 *maar zou 121311xxx,
 */
cov_1m16qsgt43.s[37]++;
for (var i = 0; i < INSTANCES_PER_TUPLE; i++) {
	cov_1m16qsgt43.s[38]++;

	for (var j = 0; j < INSTANCES_PER_TUPLE; j++) {
		cov_1m16qsgt43.s[39]++;

		for (var k = 0; k < INSTANCES_PER_TUPLE; k++) {
			var _index = (cov_1m16qsgt43.s[40]++, indexes[i][j][k]);
			var m = (cov_1m16qsgt43.s[41]++, matchings[i][j][k]);
			cov_1m16qsgt43.s[42]++;
			_assert2.default.equal(_index + Math.round(Math.random() * 100) & MAX_INVERSE_INT32, _index, 'index: ' + _index.toString(2) + ' does not match ' + m.toString(2) + '::' + [i, j, k].toString());
		}
	}
}

function pad(n, width, z) {
	cov_1m16qsgt43.f[0]++;
	cov_1m16qsgt43.s[43]++;

	z = (cov_1m16qsgt43.b[0][0]++, z) || (cov_1m16qsgt43.b[0][1]++, '0');
	cov_1m16qsgt43.s[44]++;
	n = n + '';
	cov_1m16qsgt43.s[45]++;
	return n.length >= width ? (cov_1m16qsgt43.b[1][0]++, n) : (cov_1m16qsgt43.b[1][1]++, new Array(width - n.length + 1).join(z) + n);
}

var start = (cov_1m16qsgt43.s[46]++, {
	bitmask: FIRST__LEVEL_BITMASK,
	start_bit: FIRST__TUPLE_START_BIT,
	hash: 0,
	bin: matchings[0][0][0].toString(2),
	f: parseInt('11111111111110000000000000000', 2),
	f_bin: '111111111111110000000000000000',
	m: parseInt('0000000000000000000000000000000000', 2),
	m_bin: '0000000000000000000000000000000000',
	index: 0,
	uihash: pad(0, 3),
	display: '0000',
	depth: 0,
	deeper: []
});
cov_1m16qsgt43.s[47]++;
start.base = start;
//p is the Jump from Tuple to Tuple
cov_1m16qsgt43.s[48]++;
start.p = [start, start, start];

cov_1m16qsgt43.s[49]++;
for (var first = 0; first < INSTANCES_PER_TUPLE; first++) {
	cov_1m16qsgt43.s[50]++;

	start.deeper[first] = {
		bitmask: SECOND_LEVEL_BITMASK,
		start_bit: SECOND_TUPLE_START_BIT,
		f: parseInt('11111110000001111110000000000', 2),
		m: parseInt('0000000000000000000000000000000000', 2) + parseInt('00000000000000000000000010000000000', 2) * first,
		bin: matchings[first][0][0].toString(2).substring(0, matchings[first][0][0].toString(2).length - 10),
		display: first + '000',
		base: start,
		depth: 1,
		index: first,
		uihash: pad(first, 3),
		hash: FIRST__LEVEL_TUPLE * first,
		deeper: [],
		parent: start
		//p is the Jump from Tuple to Tuple
	};cov_1m16qsgt43.s[51]++;
	start.deeper[first].p = [start, start.deeper[first], start.deeper[first], start.deeper[first]];
	cov_1m16qsgt43.s[52]++;
	if (first > 0) {
			cov_1m16qsgt43.b[2][0]++;
			cov_1m16qsgt43.s[53]++;
			start.deeper[first].previous = start.deeper[first - 1];
		} else {
		cov_1m16qsgt43.b[2][1]++;
	}cov_1m16qsgt43.s[54]++;
	if (first > 0) {
			cov_1m16qsgt43.b[3][0]++;
			cov_1m16qsgt43.s[55]++;
			start.deeper[first - 1].next = start.deeper[first];
		} else {
		cov_1m16qsgt43.b[3][1]++;
	}cov_1m16qsgt43.s[56]++;
	for (var second = 0; second < INSTANCES_PER_TUPLE; second++) {
		cov_1m16qsgt43.s[57]++;

		start.deeper[first].deeper[second] = {
			base: start,
			f: parseInt('0000001111111111110000000000', 2),
			m: parseInt('0000000000010000000000000000', 2) * second + parseInt('0000000000000000000010000000000', 2) * first,
			bin: matchings[first][second][0].toString(2),
			bitmask: THIRD__LEVEL_BITMASK,
			display: first + '' + second + '00',
			start_bit: THIRD__TUPLE_START_BIT,
			index: second,
			uihash: pad(second, 3),
			depth: 2,
			hash: first * FIRST__LEVEL_TUPLE + SECOND_LEVEL_TUPLE * second,
			deeper: [],
			parent: start.deeper[first]
			//p is the Jump from Tuple to Tuple
		};cov_1m16qsgt43.s[58]++;
		start.deeper[first].deeper[second].p = [start, start.deeper[first], start.deeper[first].deeper[second], start.deeper[first].deeper[second]];
		cov_1m16qsgt43.s[59]++;
		if (second > 0) {
				cov_1m16qsgt43.b[4][0]++;
				cov_1m16qsgt43.s[60]++;
				start.deeper[first].deeper[second].previous = start.deeper[first].deeper[second - 1];
			} else {
			cov_1m16qsgt43.b[4][1]++;
		}cov_1m16qsgt43.s[61]++;
		if (second > 0) {
				cov_1m16qsgt43.b[5][0]++;
				cov_1m16qsgt43.s[62]++;
				start.deeper[first].deeper[second - 1].next = start.deeper[first].deeper[second];
			} else {
			cov_1m16qsgt43.b[5][1]++;
		} //this level is only used to set values, not to resolve them,
		cov_1m16qsgt43.s[63]++;
		for (var third = 0; third < INSTANCES_PER_TUPLE; third++) {
			cov_1m16qsgt43.s[64]++;

			start.deeper[first].deeper[second].deeper[third] = {
				base: start,
				/* f: (parseInt('0001111111111111111110000000000', 2)),*/
				/*  m: (parseInt('00000000000000000010000000000000000', 2) * second) + (parseInt('00000000000000000000000010000000000', 2) * first),
     bin: (matchings[first][second][third]).toString(2),*/
				bitmask: FOURTH_LEVEL_BITMASK,
				display: first + '' + second + '' + third + '0',
				start_bit: THIRD__TUPLE_START_BIT,
				index: third,
				depth: 3,
				uihash: pad(third, 3),
				hash: first * FIRST__LEVEL_TUPLE + SECOND_LEVEL_TUPLE * second + THIRD__LEVEL_TUPLE * third,
				deeper: [],
				parent: start.deeper[first].deeper[second]
				//p is the Jump from Tuple to Tuple
			};cov_1m16qsgt43.s[65]++;
			start.deeper[first].deeper[second].deeper[third].p = [start, start.deeper[first], start.deeper[first].deeper[second], start.deeper[first].deeper[second].deeper[third]];

			cov_1m16qsgt43.s[66]++;
			if (third > 0) {
					cov_1m16qsgt43.b[6][0]++;
					cov_1m16qsgt43.s[67]++;
					start.deeper[first].deeper[second].deeper[third].previous = start.deeper[first].deeper[second].deeper[third - 1];
				} else {
				cov_1m16qsgt43.b[6][1]++;
			}cov_1m16qsgt43.s[68]++;
			if (third > 0) {
					cov_1m16qsgt43.b[7][0]++;
					cov_1m16qsgt43.s[69]++;
					start.deeper[first].deeper[second].deeper[third - 1].next = start.deeper[first].deeper[second].deeper[third];
				} else {
				cov_1m16qsgt43.b[7][1]++;
			}
		}
	}
}

/**
 *
 * return start values in given tuple
 * It would be nice to use the null-tuple(0instance) T(0,{*,}) as base
 * Since else we could only query 0,..* in this method.
 */
cov_1m16qsgt43.s[70]++;
global.TVALUES = function (fIds, func, fId, x, y, z, v, m) {
	cov_1m16qsgt43.f[1]++;

	var current = (cov_1m16qsgt43.s[71]++, y),
	    returnValue = (cov_1m16qsgt43.s[72]++, []);
	var tinstancecount = (cov_1m16qsgt43.s[73]++, TINSTANCECOUNT(fIds, v, y));
	cov_1m16qsgt43.s[74]++;
	for (var i = 0; i <= tinstancecount; i++) {
		cov_1m16qsgt43.s[75]++;

		returnValue.push(func(fId, x, y.deeper[i], z, v, m));
	}
	/*   while (current && tinstancecount >= current.index) {
  var tempValue = func(fId, x, current, z, v);
  returnValue.push(tempValue);
  current = current.next;
  }*/
	cov_1m16qsgt43.s[76]++;
	return returnValue;
};
/**
 * TINSTANCECOUNT is 0 based. TCOUNT is the friendly 1based version
 */
cov_1m16qsgt43.s[77]++;
global.TCOUNT = function (fIds, func, fId, x, y, z, v) {
	cov_1m16qsgt43.f[2]++;
	cov_1m16qsgt43.s[78]++;

	return TINSTANCECOUNT(fIds, v, y) + 1;
};
cov_1m16qsgt43.s[79]++;
global.REVERSEYAXIS = function (index, y) {
	cov_1m16qsgt43.f[3]++;
	cov_1m16qsgt43.s[80]++;

	return (y.bitmask & index) >> y.start_bit;
};

function indexToArray(index, y) {
	cov_1m16qsgt43.f[4]++;

	var repre = (cov_1m16qsgt43.s[81]++, [(index & THIRD__LEVEL_BITMASK) >> THIRD__TUPLE_START_BIT, (index & SECOND_LEVEL_BITMASK) >> SECOND_TUPLE_START_BIT, (index & FIRST__LEVEL_BITMASK) >> FIRST__TUPLE_START_BIT]);
	var match = (cov_1m16qsgt43.s[82]++, [(y.m & THIRD__LEVEL_BITMASK) >> THIRD__TUPLE_START_BIT, (y.m & SECOND_LEVEL_BITMASK) >> SECOND_TUPLE_START_BIT, (y.m & FIRST__LEVEL_BITMASK) >> FIRST__TUPLE_START_BIT]);
	cov_1m16qsgt43.s[83]++;
	_log2.default.info('input:' + repre + ' filter with : ' + (y.f >> 10).toString(2) + ' {' + match + '(' + y.depth + ',' + y.index + ')}' + ' gives:' + ((y.bitmask & index) >> y.start_bit));
}

//return tuplecount, get max tuple index given a (y) context.
//Conceptually, if a value exists in a given range. There is an Tuple-Instance
//Nested tuples start hash 0,0,0  So there is a Tuple instance on start three dimensions when a value is entered in the deepest level.
cov_1m16qsgt43.s[84]++;
global.TINSTANCECOUNT = function (fIds, v, y) {
	cov_1m16qsgt43.f[5]++;

	var max = (cov_1m16qsgt43.s[85]++, -1);
	//consider transforming into a bin-tree
	//Since the dimensions are Infinite, indexing becomes complex.
	cov_1m16qsgt43.s[86]++;
	for (var fid = 0; fid < fIds.length; fid++) {
		var fId = (cov_1m16qsgt43.s[87]++, fIds[fid]);
		var tempkeys = (cov_1m16qsgt43.s[88]++, []);
		var keys = (cov_1m16qsgt43.s[89]++, Object.keys(v[fId]));
		//quick-fix remove NULL values..
		//when looking for the instance-count with Y provided we also have to filter keys that are in other contexts.
		//TODO: step1 ake key filter, with the bit-mask on y. context. rest keys are not interesting.
		//TODO: start make unit testIndex, testing this function only.
		//The Tuple-Dimension is 0based, All values are placed within the first Tulpe (or non-exsistant)
		//Meaning that Any value in the Tuple Instance implies a Tuple-Instance is created.
		//index: 0000001 makes TupleCount=0
		//no index: makes TupleCount=-1
		//index: 0100001: makes TupleCount=1
		//this y.root is too cheap. It is possible to have a nested tuple instance abc2 but not have abc0
		//So 0 is allowed when a Key has this prefix.
		//the .root affix is strange there just should be a value on the corresponding tuple range to confirm its existence

		cov_1m16qsgt43.s[90]++;
		for (var i = 0; i < keys.length; i++) {
			var obj = (cov_1m16qsgt43.s[91]++, keys[i]);
			var userKey = (cov_1m16qsgt43.s[92]++, parseInt(obj));
			// the found value should have a meaning, should have a value in the tuple-range and should match parent mask
			//Why should it have a value in the Tuple-Range?
			//Is this the same as living in the Parent-Context..
			/*
    *   00000009
    *   00001101
    *   Oke inverse bitmask van me parent.
    *   ~0000 maakt 1111 die & ik met me eigen hash. Als die niet null opleverd. Dan hoort hij er niet thuis
    *
    */
			//this should match any tuple bits and validate it with the hash,
			//most important mistake is to math with the HASH, since it should match parent.hash
			//011        001
			//010 match  010 no match
			//first level just matching everything that does not have 2-tuple or 3-tuple keys
			//second level match everything on 1-tuple index. But should not have anything on the 3-tuple
			cov_1m16qsgt43.s[93]++;
			if ((cov_1m16qsgt43.b[9][0]++, v[fId][obj] != null) && (cov_1m16qsgt43.b[9][1]++, (userKey & y.f) == y.m)) {
				cov_1m16qsgt43.b[8][0]++;
				cov_1m16qsgt43.s[94]++;

				if (_log2.default.DEBUG) {
						cov_1m16qsgt43.b[10][0]++;
						cov_1m16qsgt43.s[95]++;
						indexToArray(userKey, y);
					} else {
					cov_1m16qsgt43.b[10][1]++;
				}cov_1m16qsgt43.s[96]++;
				tempkeys.push(userKey);
			} else {
				cov_1m16qsgt43.b[8][1]++;
			}
		}

		cov_1m16qsgt43.s[97]++;
		if (tempkeys.length == 0) {
			cov_1m16qsgt43.b[11][0]++;
			cov_1m16qsgt43.s[98]++;

			continue;
		} else {
				cov_1m16qsgt43.b[11][1]++;
				cov_1m16qsgt43.s[99]++;
				if (tempkeys.length == 1) {
					cov_1m16qsgt43.b[12][0]++;
					cov_1m16qsgt43.s[100]++;

					max = Math.max(max, (y.bitmask & tempkeys[0]) >> y.start_bit);
				} else {
					cov_1m16qsgt43.b[12][1]++;
					cov_1m16qsgt43.s[101]++;

					max = Math.max(max, tempkeys.reduce(function (a1, b1) {
						cov_1m16qsgt43.f[6]++;
						cov_1m16qsgt43.s[102]++;

						//filter bits  y.start_bit find highest tuple count identified with y.bitmask
						//look for start values and obtain tuple instance value
						//we don't have to y.bitmask? its just >> y.start_bit
						return Math.max((y.bitmask & a1) >> y.start_bit, (y.bitmask & b1) >> y.start_bit);
					}));
				}
			}
	}
	cov_1m16qsgt43.s[103]++;
	return max;
};
/*
 * Conceptually checks:
 * From here we will build the concept
 * 1-(2-tuple)
 * 2-(1-tuple)
 * 3-(0-tuple)
 * 4-(column10)
 * 5-(column01)
 * [1][2][3][4][5]
 *
 * The filter means the ** wildcard
 * The match means the tuple context
 */
//er is geen wens om 1*1 te testen, er word nooit gevraagd van hoeveeel tuples bijvoorbeeld 3tuples hebben.
var combine = (cov_1m16qsgt43.s[104]++, [{
	reg: '000**', match: '00000', filter: '11100',
	fit: ['00010', '00011', '00001', '00000'],
	nofit: ['00110', '01110', '11110', '10110', '10010']
}, {
	reg: '001**', match: '00100', filter: '11100',
	fit: ['00110', '00111'],
	nofit: ['00010', '01010', '11010', '11110']
}, {
	reg: '011**', match: '01100', filter: '11100',
	fit: ['01100', '01101'], nofit: ['10100', '11100', '00100', '11000']
}, {
	reg: '010**', match: '01000', filter: '11100',
	fit: ['01010'],
	nofit: ['00010', '00000']
}, {
	reg: '11***', match: '11000', filter: '11000',
	fit: ['11000', '11100'],
	nofit: ['01100', '00000', '01100']
}, { //the first check, how many instances on root?
	reg: '00***', match: '00000', filter: '11000',
	fit: ['00000', '00001'],
	nofit: ['01100', '10000', '01100']
}, {
	reg: '01***', match: '01000', filter: '11000',
	fit: ['01000'], nofit: ['00000']
}, {
	reg: '1****', match: '10000', filter: '10000',
	fit: ['10101'], nofit: ['01000']
}]);
cov_1m16qsgt43.s[105]++;
for (var testIndex = 0; testIndex < combine.length; testIndex++) {
	var test = (cov_1m16qsgt43.s[106]++, combine[testIndex]);
	cov_1m16qsgt43.s[107]++;
	for (var i = 0; i < test.fit.length; i++) {
		cov_1m16qsgt43.s[108]++;
		(0, _assert2.default)((parseInt(test.fit[i], 2) & parseInt(test.filter, 2)) == parseInt(test.match, 2));
	}cov_1m16qsgt43.s[109]++;
	for (var i = 0; i < test.nofit.length; i++) {
		cov_1m16qsgt43.s[110]++;
		(0, _assert2.default)((parseInt(test.nofit[i], 2) & parseInt(test.filter, 2)) != parseInt(test.match, 2));
	}
}
/*
 * oke hoe maak ik nou zo'n object?
 * de sterretjes betekenen op beide filter als match een 0
 * de 0/1 betekend in match een kopie
 * de 0/1 betekend in filter een 1
 * De reg betekend T(0,0,0)
 *
 * De vragen die worden gesteld zijn: wat is YCount, gegeven index[] en Y
 * dus: Y heeft
 * t(R) = f(t*<R?1:0)
 * dus uit [t1,t2,t3] = filter: t1(R)+t2(R)+t3(R)+,00  e.g. hoeveel t2 in [1,0,*]? 110,00
 * dus uit [t1,t2,t3] =  match: t1t2t3+,00             e.g.               [1,0,*]? 100,00
 * uit gegeven [*,*,*] moet ik die twee dingen halen.
 *
 * Dus als ik wil weten hoeveel Y in [a,b,c]
 * Dan '1'.repeat(bits), voor 0,0,0 wil ik  111 filter en match 000, maar die bestaat dus niet
 * Dan '1'.repeat(bits), voor 0,1,0 wil ik  110 filter en match 110
 *
 * filter: 111111,111111,111111,0000000000 voor 0,0,0
 *  match: 000000,000000,000000,0000000000 voor 0,0,0 (word niet gebruikt, impliceert 0,0,0,*)
 * filter: 111111,111111,111111,0000000000 voor 0,0,1
 *  match: 000000,111111,000001,0000000000 voor 0,0,1 (word niet gebruikt, impliceert 0,0,0,*)
 * filter: 111111,111111,000000,0000000000 voor 0,0,*
 *  match: 000000,000000,000000,0000000000 voor 0,0,*
 * filter: 111111,000000,111111,0000000000 voor 0,*,1
 *  match: 000000,000000,000001,0000000000 voor 0,*,1
 *
 *  Filter geeft alleen aan in welke sector de max-waarde gezocht word. dat kan slot1,slot2,of slot3 zijn
 *  De Match geeft aan in welke context de vraag moet passen.
 *  011 & f(0,*,1) = m(0,1,1)
 *  001 & f(0,*,1) = m(0,1,1)
 *
 *  filter kan op het moment alleen *,*,* of *,0,* of 0,*,* zijn.
 *
 *  filter op level 0 = **. = 110
 *  filter op level 1 = *.* = 101
 *  filter op level 2 = .** = 011
 *
 *  Dus dat gaan we toevoegen aan het geheel
 */

//columns we need aprox 512 10bit
//53 total bits to use, 43bit for tuples, 8*8*8*8 (32bit) 8bit represent 128 instances. 4dimensions 128 instances. takes 32 bit
/*
 * It can grow into 5dimensions having 128instances each using 40bit, leaving 10bits for columns. We have to figure out operations without binair operators
 * A binair operator in javascript works until 32bits (4*8) So we have to calculate the index in a different way when exceeding these limits.
 */
exports.default = start.deeper;