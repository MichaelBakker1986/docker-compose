#Idea behind XAxis:
Every variable(t0,t1,t2) can hold up to 256 values
 USER|DOC|{TREND|NOTREND|AGG}+
 First value is reserved for USER value, defined with the USER-Formula       - This could be MIN(Self[lastbkyear],100) to see all values from the last bookyear with a minimal value of 100
 Second value is reserved for the DOCUMENT value, with the 'default'-Formula - Often used for overall settings.
 Trend|NoTrend|AGG values are reserved for values in time The user decides when Trend|NoTrend starts and ends. Combined with aggregation formula's
  e.g.
0     (USER)
1     (DOCUMENT)
    2 (detail)
    3 (detail)
    4 (detail)
   5  (quart_bkyear) agg(2,3,4)
    6 (detail)
    7 (detail)
    8 (detail)
   9  (quart_bkyear) agg(6,7,8)
 10   (half_bkyear)  agg(5,9)
[.....]

Aggregation formulaset would be like If(FLOW,Self[prev])                  -- (!) previous column can be aggregation column
                                     If(BALANCE,SUM(Self[t.agg_columns])) --

Inverse aggregation:(~~similar to flip-flop) if(DataEntered(Self|Aggregated)) SUM(Self[agg]/fraction)
 -- So the formula for these types are more complex to perform.

Introducing valuation formulaset could be done in the USER- formulaset, when the USER-formulaset is already taken. We need to introduce another formulaset.

-- https://www.npmjs.com/package/js-solver solver module to find flip-flop value.


/*
 * TIME:
 * Absolutely remove title from this Dimension
 * Since time has nothing to do with formula formula-sets [trend,notrend]
 * We could index all properties with 8bits...  since there is never a need of 128 different properties
 *  TODO: this also includes the legacy more-complex 'title-prefix-column'. Remove the title column
 *  TODO: Timelines dimension is no longer used within the engine since they are accumulated with the database
 *
 *  Here we will do column/timeline ordering, referencing previous and adjacent columns
 *
 *  The variable decorator should suply the referenced column to write into
 *  Period[T=12] will be referred to Period[1]
 *  When Period:
 *  variable.columns[12] will be referred to variable.columns[1]
 *  variable.columns[27] will be referred to variable.columns[2] etc..
 *
 *  When Document
 *  variable.columns[*] will be referred to variable.columns[1?0]

 *  When Detail
 *  variable.columns[x] will be referred to variable.columns[x]
 */
//Detail can refer to its Period
//Detail will refer it its own Detail, else [bky] or [prev] has to be supplied
//Detail can refer to Document
//Period will refer to first Detail, else [first] or [last] or [bky] has to be supplied
//Period will refer to its own Period, else [forecast] or [history] has to be supplied
//Period can refer to Document
//Document will refer to first Detail, else [first] or [last] or [bky] has to be supplied
//Document will refer to first Period, else [forecast] or [history] has to be supplied
//Document can only refer to itsself
//can easy be refactored for better performance
// NodeJS support..
// 25ms for 134col/5timelines
// 199ms for 134col/40timelines
// what is expected to be happen.. lineair result. 1ms boiler plate 5ms*timeline for 134cols
// 280ms for 234cols 40timelines. Very acceptable 12year 40timelines 280ms..
// columns can also be mixed in tsy. so 5x1d and then (7*12)bkyr.tsy. Allow 100year forecast., would require some nice
// tricks here.. but possible from here only prevbkyear, might consider removing *[agg*], only keep the *[top*]
// currently we have max7 year 10timelines

import java.lang.Math;
import static java.lang.Math.*;
public class MyClass {
    public static void main(String args[]) {
        double sample=0.08223466368715092;
        double other = exp(2.39328);
        double quote=0.012;
        double pd=(1.0/(1.0+(other *sample)*((1.0-quote)/quote)));

        System.out.println("Sum of x+y = " + pd);
    }
}
